# FillRaw

პრობლემა:
```
კარელი დგას 1x1 უჯრაზე, შეავსებინეთ მას პირველი ქუჩა ბრილიანტებით. ანუ პირველი ქუჩის ყველა უჯრაზე უნდა იდოს ზუსტად ერთი ბრილიანტი. ჩათვალეთ რომ საწყის სამყაროში ბრილიანტები არსად არ დევს.
```



## პრობლემის გადაჭრის გზა
პირველ რიგში ჩვენი პრობლემა დავყოთ ორ ნაწილად
* კარელმა უნდა გაიაროს მთლიანი ქუჩა
* სიარულთან ერთად, კარელმა პარალელურად უნდა განათავსოს ბიპერები ქუჩაზე

---

### მთლიანი ქუჩის გავლის პრობლემას გადავჭრით შემდეგი საშაულებით
1. გამოვიყენოთ კარელისათვის ცნობილი `frontIsClear()` მეთოდი.
2. გამოვიყენოთ `while ( პირობა )` ციკლი.
3. წინაღობის შემოწმების შემდგომ, განვახორციელოთ 1 უჯრით წინ გადანაცვლება `move()` მეთოდის საშუალებით, რათა შევძლოთ მთლიანი ქუჩის გავლა.


შესაბამისად, მივიღებთ კოდს:
```java
while(frontIsClear()) {

    move();
}
```

> *როდესაც კარელის წინ აღმოჩნდება კედელი, `frontIsClear()` მეთოდი `while ( პირობა )` ციკლს შეატყობინებს, რომ კარელის წინ დაბრკოლებაა და კარელი შეწყვიტავს სვლას. (ციკლი დასრულდება)*

---

### სიარულის პარალელურად, ბიპერების განთავსება ქუჩაზე
ახლა, როდესაც კარელი წარმატებით გადის ქუჩას, მნიშვნელოვანია ბიპერების განთავსება, რომელსაც `putBeeper()` მეთოდის საშუალებით გავაკეთებთ. მისი `while` ციკლში მოთავსებით კოდი მიიღებს შემდეგ სახეს
```java
while(frontIsClear()) {
    
    putBeeper();

    move();
}
```
ამ ეტაპისთვის გვგონია, რომ პრობლემა გადაჭრილია და არანაირ მოდიფიკაციას არ საჭიროებს, თუმცა კოდის წარმატებით გაშვების შემდგომ მივიღებთ სამყაროს, სადაც კარელმა წარმატებით შეძლო მისი ქუჩის უჯრებზე მხოლოდ 1 ბიპერის განთავსება, **გარდა 1 უჯრისა.**

ეს უჯრა, სწორედ ისაა, რომელზედაც იგი მუშაობის დასასრულს იმყოფება. მოდით, განვიხილოთ თუ რას შეიძლებოდა გამოეწვია მსგავსი სახის პრობლემა.
* ამ შეცდომას პროგრამირებაში [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)-ად მოიხსენიებენ და თავისი სახელიდანვე გამომდინარე მივხვდებით, რომ შეცდომა ძირითადად **იტერირების** დროს შესაძლოა წარმოიშვას.
* განვიხილოთ კარელის შემთხვევა (სამყარო 10x10-ზე)
    * კარელი დგას მე-9 უჯრაზე.
    * დავდეთ ბიპერი.
    * გამოვიძახეთ `move()` მეთოდი და გადავინაცვლეთ მე-10 უჯრაზე.
    * მე-10 უჯრაზე გადასვლის შემდგომ კარელი ამოწმებს, მას აქვს თუ არა წინაღობა მის წინ `frontIsClear()` მეთოდი, რაზეც იგი იღებს პასუხს, რომ მის წინ მდებარეობს კედელი. შესაბამისად, კარელი ასრულებს `while` ციკლს და ვეღარ ახერხებს `putBeeper()` მეთოდის გამოძახებას.

![Image Of Karel Standing on 10th Box](https://i.imgur.com/XQRF1oc.png)

ამ ყველაფრის შემდგომ, პრობლემის გადასაჭრელად, დაგვჭირდება `putBeeper()` მეთოდის ჩამატება ჩვენს კოდში:
```java
while(frontIsClear()) {
    
    putBeeper();

    move();
}

// დებს ბიპერს, ბოლო უჯრაზე
putBeeper();
```
---

## რატომ იმუშავებს კოდი ნებისმიერი სამყაროს ზომისათვის?
* განვიხილოთ სამყარო, რომლის სიგრძეც 1-ის ტოლია (სიმაღლეს მნიშვნელობა არ აქვს, ვინაიდან კარელი მოძრაობს მარცხნიდან მარჯვნივ, მხოლოდ).
    * ჩვენს მიერ დაწერილი კოდი, პირველ რიგში შეამოწმებს, არის თუ არა კარელის წინ კედელი.
    * `frontIsClear()` მეთოდი დააბრუნებს პასუხს, რომ კარელს გზა დაბლოკილი აქვს და ვერ შეძლებს წინ წასვლას, შესაბამისად კარელი გამოტოვებს `while` ციკლს
    * კარელი გადაინაცვლებს `while` ციკლის შემდგომ ბრძანებაზე და დახვდება `putBeeper()` მეთოდი, რაც უზრუნველყოფს ბიპერის წარმატებით დადებას სამყაროში. შესაბამისად, ჩვენი პრობლემაც გადაჭრილია და კარელი იდგება ქუჩაზე, რომლის ყველა უჯრაზე მხოლოდ 1 ბიპერი დევს
    
    ![Karel in 1x10 World](https://i.imgur.com/RwZB99V.png)

* ნებისმიერი სხვა სამყაროსთვის, რომლის სიგრძეც > 1, ზუსტად იგივე ლოგიკით იმუშავებს, როგორც ზემოთხსენებული 10x10 სამყაროზე იმიტომ, რომ კარელი ამოწმებს წინ არსებულ დაბრკოლებას და მხოლოდ ამის შემდგომ იღებს გადაწყვეტილებას, გააგრძელოს თუ დაასრულოს სვლა.

---

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
პირველ რიგში, მინდა მოგილოცოთ პროგრამის დასრულება წარმატებით დასრულება და იმპლემენტაცია, თუმცა არსებობს 2 დეტალი, რისი გათვალისწინებაც საკმაოდ მნიშვნელოვანია ამ ამოცანის გადაჭრისას

1. გასათვალისწინებელია ზემოთ ნახსენები [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)
2. ასევე, საინტერესოა, რა მოხდება თუ `while` ციკლის ტანში ადგილებს გავუცვლით `move()`-სა და `putBeeper()` მეთოდებს. ერთი შეხედვით თითქოს ისევ სწორად უნდა იმუშაოს პროგრამამ, ვინაიდან ჩვენ მხოლოდ 2 ბრძანებას გავუცვალეთ ადგილი.
    1. მივიღებთ კოდს 
        ```java
        while(frontIsClear()) {
            
            move();

            putBeeper();
        }

        putBeeper();
        ```
    2. თუ კარგად დავაკვირდებით და გავიაზრებთ კოდს, შევამჩნევთ, რომ კარელის ქმედებები შეიცვლება.
        * კოდის გაშვების შემდეგ კარელი ჯერ გადაინაცვლებს მეორე უჯრაზე, ხოლო ამის შემდეგ დადებს ბიპერს.
        * თავისთავად ჩვენს კოდში წარმოიშვა ხარვეზი, რაც მოიაზრებს შემდეგს: კარელის სამყაროში პირველი უჯრა ყოველთვის ცარიელი დარჩება, ხოლო დამთავრების ადგილას იგივე განათავსებს 2 ბიპერს.
    3. ამ პრობლემას 1 მარტივი გადაჭრის გზა აქვს.
        1. ავიტანოთ `while` ციკლის გარეთ მყოფი `putBeeper()` მეთოდი და გამოვიძახოთ `while` ციკლის გამოძახებამდე.
        2. ახალი კოდი 
            ```java
            putBeeper();
            
            while(frontIsClear()) {
                
                move();

                putBeeper();
            }
            ```

